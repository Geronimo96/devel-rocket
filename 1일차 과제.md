
## 💻 프로그래밍 개요 (25.12.08)
> 과제 1. 주 기억장치와 보조 기억장치
- 컴퓨터를 구성하는 주요 하드웨어 중 '주 기억장치'와 '보조 기억장치'의 차이점에 대해 서술하시오

주기억 장치와 보조 기억 장치는 컴퓨터 시스템에서 데이터를 저장하는 두 가지 주요 유형의 저장 장치이며, 속도, 휘발성, 용량, 그리고 CPU의 접근 방식에서 근본적인 차이가 있습니다.

---

#### 💾 주 기억 장치 (Primary Storage, Main Memory)
주기억 장치는 CPU가 현재 실행 중인 프로그램의 명령어와 데이터를 직접 저장하고 접근하는 장치입니다. 우리가 흔히 **RAM(Random Access Memory)**이라고 부르는 것이 대표적입니다.

| 특징 | 설명 |  
|---|---|
| **속도** | **매우 빠름** (CPU 속도와 근접), 시스템 내에서 보조 기억 장치보다 훨씬 빠르게 데이터를 읽고 쓸 수 있습니다. |  
| **휘발성** |  ***휘발성(Volatile)*** 입니다. 전원 공급이 끊기면 저장된 모든 데이터가 사라집니다.    |  
| **용량 및 가격**  | **용량이 작고** (GB 단위), 보조 기억 장치에 비해 **가격이 비쌉니다.**|  
| **CPU 접근** | **CPU가 직접 접근**하여 데이터를 처리합니다. |
| **역할** | 현재 실행되는 운영체제, 응용 프로그램, 및 데이터를 임시로 저장하여 **CPU의 작업 효율성**을 높입니다.
| 예시 | **RAM(DRAM, SRAM)**, 캐시 메모리(Cache Memory), ROM(Read-Only Memory). |

---

#### 💿 보조 기억 장치 (Secondary Storage, Auxiliary Storage)
보조 기억 장치는 데이터를 장기간, 영구적으로 저장하기 위해 사용되는 장치입니다.

| 특징 | 설명 |  
|---|---|
| **속도** | **느림** (주기억 장치에 비해). 데이터 접근 시 시간이 더 오래 걸립니다. |  
| **휘발성** |  ***비휘발성(Non-Volatile)*** 입니다. 전원 공급이 끊겨도 저장된 데이터가 그대로 유지됩니다.   |  
| **용량 및 가격** | ** 용량이 크고** (TB 단위), 주기억 장치에 비해 **가격이 저렴합니다.**|  
| **CPU 접근** | **CPU가 직접 접근할 수 없습니다.** 데이터를 주기억 장치(RAM)로 옮긴 후에야 CPU가 처리할 수 있습니다. |
| **역할** | 운영체제 파일, 응용 프로그램, 개인 문서 파일 등 **모든 데이터와 프로그램을 영구적으로 저장**합니다.
| **예시** | **HDD(Hard Disk Drive), SSD(Solid State Drive)**, USB 드라이브, CD/DVD. |

#### 📊 주요 차이점 요약 비교

| 구분     | 주기억 장치 (RAM)    | 보조 기억 장치 (HDD/SSD 등)     |
| ------ | ----------------------- | ------------------------ |
| **용도**     | 실행 중인 프로그램 및 데이터의 **임시 저장** | 모든 프로그램 및 데이터의 **영구 저장**     |
| **휘발성**    | **휘발성** (전원 차단 시 데이터 손실)   | **비휘발성** (전원 차단 시 데이터 유지)  |
| **속도**     | **매우 빠름**  | **느림** |
| **CPU 접근** | **직접 접근** 가능  | **직접 접근 불가** (주기억 장치를 거쳐야 함) |
| **용량**     | 작음 (GB 단위)   | 큼 (TB 단위)  |
| **가격**     | 비쌈 (용량 당)   | 저렴함 (용량 당)   |


---

> 과제 2. 응용 프로그램과 시스템 프로그램
- 자신이 사용해본 대표적인 응용 프로그램을 5개 기재하시오
  - 웨일 브라우저
  - Photoshop & Illustrator
  - GTA 5
  - Discord
  - Notion

- 자신이 사용해본 시스템 프로그램을 모두 기재하시오
  - Linux
  - Microsoft 


> 과제 3. 이진수 및 바이트 변환
- 십진수인 824748을 이진수로 변환하시오

십진수를 이진수로 변환하는 가장 **효율적이고 표준적인 방법**은 **2로 나누어 나머지를 취하는 방법(Repeated Division by 2)**입니다.

이 방법은 십진수를 2진수의 각 자릿값(비트)에 해당하는 $2^n$의 합으로 분해하는 원리를 이용합니다.


#### 2로 나누어 나머지를 취하는 방법 (Repeated Division by 2)

이 방법은 십진수 $N$을 2로 연속적으로 나누어 **몫이 0이 될 때까지** 진행하며, 이때 발생하는 **나머지들을 역순으로** 나열하면 이진수가 됩니다.

#### 📝 변환 단계

1.  **나누기:** 주어진 십진수를 2로 나눕니다.
2.  **나머지 기록:** 나눗셈의 나머지를 기록합니다. (나머지는 항상 0 또는 1입니다.)
3.  **몫 재사용:** 새로 얻은 **몫**을 다음 단계의 십진수로 사용합니다.
4.  **반복:** 몫이 0이 될 때까지 1~3단계를 반복합니다.
5.  **결과 확인:** 기록한 나머지들을 **가장 마지막에 얻은 나머지부터 역순으로** 배열하면 이진수가 됩니다.

### 💡 예시: 십진수 $45$를 이진수로 변환

| 계산 (몫 $\div 2$) | 몫 | 나머지 |
| :---: | :---: | :---: |
| $45 \div 2$ | 22 | **1** (최하위 비트) |
| $22 \div 2$ | 11 | **0** |
| $11 \div 2$ | 5 | **1** |
| $5 \div 2$ | 2 | **1** |
| $2 \div 2$ | 1 | **0** |
| $1 \div 2$ | 0 | **1** (최상위 비트) |

나머지를 역순으로 읽으면 $101101$이 됩니다.

---

- 이진수인 101101을 십진수로 변환하시오
  
이진수 $101101_2$를 십진수로 변환하는 가장 효율적인 방법은 **2의 거듭제곱(자릿값)**을 이용하는 것입니다.

이진수의 각 자릿값은 오른쪽(최하위 비트)부터 시작하여 $2^0, 2^1, 2^2, 2^3, \dots$의 값을 가집니다. 해당 자리에 '1'이 있으면 그 자릿값을 더하고, '0'이 있으면 무시합니다.

#### 🧮 십진수 변환 과정

주어진 이진수 $101101_2$의 각 자리에 해당하는 2의 거듭제곱을 나열합니다.

| 이진수 자릿값 | 1 | 0 | 1 | 1 | 0 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **2의 거듭제곱** | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ |
| **십진수 값** | 32 | 16 | 8 | 4 | 2 | 1 |

$$32 + 0 + 8 + 4 + 0 + 1 = 45$$
$$\mathbf{101101_2 = 45_{10}}$$

---

- 12 byte는 몇 bit 인지 기재하시오

12 byte는 **96 bit**입니다.

#### 🧮 계산 과정

컴퓨터 데이터 단위의 기본 관계는 다음과 같습니다.
$$\mathbf{1 \text{ byte} = 8 \text{ bits}}$$

따라서 12 byte를 bit로 변환하려면 8을 곱하면 됩니다.

$$12 \text{ byte} \times 8 \text{ bits/byte} = \mathbf{96 \text{ bits}}$$

| 단위 | 값 |
| :---: | :---: |
| **12 byte** | **96 bit** |

---

> 과제 4. 블로그 개설

[Obsidian](https://publish.obsidian.md/dnd)

> 과제 5. IDE 설치 

![IDE 설치](20251208_160419.png)

> 과제 6. (심화/선택사항) 32bit/64bit
- Windows OS 기준 32bit와 64bit 버전의 차이점을 메모리와 연관지어 설명하시오.

Windows OS에서 **32비트(x86)** 버전과 **64비트(x64)** 버전의 가장 큰 차이점은 **메모리(RAM) 주소 지정 능력**입니다.

#### 💾 32비트와 64비트의 메모리 차이

| 특징 | 32비트 (x86) Windows | 64비트 (x64) Windows |
| :---: | :---: | :---: |
| **주소 지정 능력** | $2^{32}$ (40억 개) | $2^{64}$ (매우 큰 수) |
| **최대 인식 RAM** | 약 **4 GB**로 제한됨 (실제 사용은 3.2GB~3.5GB) | **수백 GB 이상** 지원 (거의 무제한) |
| **프로세스 메모리** | 앱 하나당 **2 GB**만 사용 가능 | 앱 하나당 **수 TB**까지 사용 가능 |

#### ① 최대 메모리 제한

* **32비트:** 메모리 주소를 32비트로 표현하므로, 이론적인 최대 메모리 용량은 **4GB**를 넘을 수 없습니다. 고용량 RAM을 장착해도 4GB까지만 인식하고 사용합니다.
* **64비트:** 메모리 주소를 64비트로 표현하여, 이론상으로는 거의 무제한의 메모리(16 엑사바이트)를 다룰 수 있습니다. 

#### ② 성능 및 활용

64비트 OS는 더 많은 메모리를 활용할 수 있기 때문에, 대용량 데이터를 처리하는 **고사양 게임, 비디오 편집, 다중 작업 환경**에서 32비트 OS보다 **훨씬 더 빠르고 안정적인** 성능을 제공합니다.

---

> 과제 7. (심화/선택사항) C# 컴파일
- C# 언어의 컴파일 과정에 대해 추가 자료를 조사하고 서술하시오.

C# 코드가 실행 가능한 프로그램으로 변환되는 과정인 **컴파일(Compilation)**은 다른 언어와는 조금 다른 독특한 방식을 사용합니다. C# 컴파일은 소스 코드를 바로 특정 운영체제나 하드웨어용 기계어 코드로 변환하는 것이 아니라, **중간 언어(Intermediate Language, IL)**로 변환하는 2단계 과정을 거칩니다.

#### 📝 C# 컴파일 과정 (2단계 모델)

C# 컴파일 과정은 크게 두 단계로 나뉩니다.

---

#### 1단계: 소스 코드에서 IL(중간 언어)로 변환

C# 컴파일러는 개발자가 작성한 C# 소스 파일(`.cs`)을 읽어들여 플랫폼 독립적인 **중간 언어(IL)** 코드로 변환합니다.

* **컴파일러 역할:** C# 컴파일러는 구문 오류 등을 검사하고, 코드를 **MSIL (Microsoft Intermediate Language)** 또는 **CIL (Common Intermediate Language)**이라고 불리는 중간 언어로 변환합니다.
* **결과물:** 이 IL 코드는 일반적으로 `.exe` 또는 `.dll` 파일 형태의 **어셈블리(Assembly)** 내에 저장됩니다. 이 파일에는 IL 코드뿐만 아니라, 코드 실행에 필요한 메타데이터(Metadata)도 포함됩니다.
* **플랫폼 독립성:** 이 단계의 결과물인 IL 코드는 특정 CPU(x86, x64, ARM 등)에 종속되지 않습니다.

---

#### 2단계: IL(중간 언어)에서 기계어 코드로 변환 (JIT 컴파일)

사용자가 `.exe` 파일을 실행하면, 운영체제가 아닌 **CLR (Common Language Runtime)**이라는 .NET 환경이 이 작업을 관리합니다. CLR은 IL 코드를 실행 시점에 해당 환경에 맞는 기계어 코드로 변환합니다.

* **JIT (Just-In-Time) 컴파일러:** CLR 내부에 있는 JIT 컴파일러가 이 역할을 수행합니다. 프로그램이 실행될 때, **필요한 코드 블록**만 그때그때 호스트 CPU가 이해할 수 있는 **네이티브 기계어 코드**로 변환합니다.
* **캐싱 및 최적화:** 한 번 JIT 컴파일된 기계어 코드는 메모리에 캐시되어, 같은 코드가 다시 호출될 때는 재컴파일 없이 빠르게 실행됩니다. 또한, JIT 컴파일러는 런타임 환경에 맞춰 추가적인 성능 최적화를 수행할 수 있습니다.
* **실행 환경:** 이 과정 덕분에 C# 코드는 Windows, Linux, macOS 등 다양한 운영체제와 CPU 아키텍처에서 수정 없이 실행될 수 있습니다.

이러한 2단계 컴파일 방식은 C# 프로그램의 **플랫폼 독립성**을 보장하고, 런타임 최적화를 가능하게 하여 **성능**과 **유연성**을 모두 확보하는 데 도움을 줍니다.
