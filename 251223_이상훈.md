> ## 과제 1. 트레이너와 몬스터 클래스 제작
* 트레이너와 몬스터 클래스를 구현하시오.
* 각 클래스는 다음과 같은 속성과 기능을 지녀야 한다.

    Class Trainer
    * 이름 : 플레이어 이름, 프로그램 시작 시 입력하도록 구현
    * 몬스터를 보관할 수 있는 크기 6의 배열
    * 현재 플레이어가 꺼내놓은 몬스터에 대한 참조를 위한 변수
    * Add() : 매개변수로 몬스터를 하나 입력받아 배열의 빈 자리에 추가. 빈 자리가 없다면 추가되지 않음
    * Remove() : 매개변수로 몬스터를 하나 입력받아(혹은 몬스터 이름이 적힌 문자열) 동일한 이름을 가진 몬스터를 배열에서 삭제. 이름에 해당하는 몬스터가 없거나 배열에 몬스터가 한마리도 없는 경우 아무 기능도 수행하지 않음.
    * PrintAll() : 자신이 가지고 있는 모든 포켓몬에 대한 정보를 출력
    * Attack() : 몬스터에게 공격 명령을 내림
    * Skill() : 몬스터에게 스킬 사용 명령을 내림

    Class Monster
    * 이름, 레벨 : 객체의 인스턴스 생성 시 new할당에서 이름과 레벨을 입력받을 수 있도록 구현
    * Print() : 자신(몬스터)에 대한 정보를 출력
    * Attack() : $"{몬스터의 이름} : {레벨 * 공격력} 데미지로 공격"을 출력
    * Skill() : Monster를 상속받은 하위 객체에서 세부구현
    * 세부 구현되는 몬스터가 Monster 클래스를 상속받도록 한다

    Class 세부구현 몬스터
    * Monster를 상속받아 Skill을 세부구현 한다.
        * 몬스터마다 고유한 스킬 이름을 출력한다
    * 세부구현 몬스터는 5종 이상을 구현한다.

> 코드

 ```csharp
using System;

namespace ConsoleApp
{
    // [1] Monster 클래스 (부모 클래스)
    public class Monster
    {
        public string Name { get; set; }
        public int Level { get; set; }
        public int Atk { get; set; } // 공격력 (과제 요구사항의 계산식을 위해 추가)

        public Monster(string name, int level)
        {
            Name = name;
            Level = level;
            Atk = 10; // 기본 공격력 설정
        }

        public void Print()
        {
            Console.WriteLine($"[정보] 이름: {Name} | Lv: {Level}");
        }

        public void Attack()
        {
            // 요구사항: "{몬스터의 이름} : {레벨 * 공격력} 데미지로 공격"
            Console.WriteLine($"{Name} : {Level * Atk} 데미지로 공격");
        }

        public virtual void Skill()
        {
            Console.WriteLine($"{Name}이(가) 스킬을 사용하려고 합니다.");
        }
    }

    // [2] 세부 구현 몬스터 (5종)
    public class Pikachu : Monster
    {
        public Pikachu(string name, int level) : base(name, level) { }
        public override void Skill() { Console.WriteLine($"[{Name}] 백만볼트!"); }
    }

    public class Charmander : Monster
    {
        public Charmander(string name, int level) : base(name, level) { }
        public override void Skill() { Console.WriteLine($"[{Name}] 화염방사!"); }
    }

    public class Squirtle : Monster
    {
        public Squirtle(string name, int level) : base(name, level) { }
        public override void Skill() { Console.WriteLine($"[{Name}] 물대포!"); }
    }

    public class Bulbasaur : Monster
    {
        public Bulbasaur(string name, int level) : base(name, level) { }
        public override void Skill() { Console.WriteLine($"[{Name}] 덩굴채찍!"); }
    }

    public class Snorlax : Monster
    {
        public Snorlax(string name, int level) : base(name, level) { }
        public override void Skill() { Console.WriteLine($"[{Name}] 누르기!"); }
    }

    // [3] Trainer 클래스
    public class Trainer
    {
        public string Name;
        private Monster[] monsters; // 몬스터 보관 배열
        private Monster currentMonster; // 현재 꺼내놓은 몬스터 참조

        public Trainer(string name)
        {
            Name = name;
            monsters = new Monster[6]; // 크기 6의 배열
        }

        // 몬스터 추가
        public void Add(Monster monster)
        {
            for (int i = 0; i < monsters.Length; i++)
            {
                if (monsters[i] == null)
                {
                    monsters[i] = monster;
                    Console.WriteLine($"{monster.Name}을(를) 잡았습니다!");

                    // 만약 현재 꺼내놓은 몬스터가 없다면 바로 꺼내놓음
                    if (currentMonster == null) currentMonster = monster;
                    return;
                }
            }
            Console.WriteLine("더 이상 몬스터를 데리고 다닐 수 없습니다. (최대 6마리)");
        }

        // 몬스터 삭제 (이름으로 삭제)
        public void Remove(string name)
        {
            bool found = false;
            for (int i = 0; i < monsters.Length; i++)
            {
                if (monsters[i] != null && monsters[i].Name == name)
                {
                    Console.WriteLine($"{monsters[i].Name}을(를) 놓아주었습니다.");

                    // 현재 꺼낸 몬스터가 삭제되는 경우 참조 해제
                    if (currentMonster == monsters[i]) currentMonster = null;

                    monsters[i] = null;
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                Console.WriteLine("그런 이름의 몬스터가 없거나, 몬스터가 비어있습니다.");
            }
        }

        // 모든 몬스터 정보 출력
        public void PrintAll()
        {
            Console.WriteLine($"=== {Name}의 몬스터 목록 ===");
            for (int i = 0; i < monsters.Length; i++)
            {
                if (monsters[i] != null)
                {
                    Console.Write($"Slot {i + 1}: ");
                    monsters[i].Print();
                }
                else
                {
                    Console.WriteLine($"Slot {i + 1}: (비어있음)");
                }
            }
            Console.WriteLine("============================");
        }

        public void Attack()
        {
            if (currentMonster != null)
            {
                currentMonster.Attack();
            }
            else
            {
                Console.WriteLine("공격할 몬스터가 나와있지 않습니다.");
            }
        }

        public void Skill()
        {
            if (currentMonster != null)
            {
                currentMonster.Skill();
            }
            else
            {
                Console.WriteLine("스킬을 쓸 몬스터가 나와있지 않습니다.");
            }
        }
    }

    // [4] 실행 테스트 (Main)
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("플레이어의 이름을 입력하세요: ");
            string playerName = Console.ReadLine();
            Trainer trainer = new Trainer(playerName);

            trainer.Add(new Pikachu("피카츄", 5));
            trainer.Add(new Charmander("파이리", 4));
            trainer.Add(new Snorlax("잠만보", 10));

            trainer.PrintAll();

            Console.WriteLine("\n[전투 테스트]");
            trainer.Attack(); // 첫 번째 추가된 피카츄가 currentMonster가 됨
            trainer.Skill();

            Console.WriteLine("\n[삭제 테스트]");
            trainer.Remove("피카츄");
            trainer.PrintAll();
        }
    }
}
  ```
  
  ---
  <br>

>## 과제 2. 출력결과 판단하기 1
* 함수에 인자가 전달될 때 일어나는 일과 연관하여 어떤 출력 결과가 나오는지 설명하시오

```csharp
void UpdateList(int[] arr)
{
    arr[0] = 99;
}

int[] numArr = new int[] { 1, 2, 3 };
UpdateList(numArr);
Console.WriteLine(numArr[0]); 

// 출력 결과: ?
```
### 출력 결과 : `99`

설명: 배열은 **참조 타입(Reference Type)** 입니다. UpdateList(`numArr`)를 호출할 때, 배열의 값이 복사되는 것이 아니라 **배열이 위치한 메모리의 주소값(참조)** 이 전달된다. 즉 `깊은 복사`가 아닌 `얕은 복사`가 일어난다. 따라서 함수 내부에서 `arr[0]`에 접근하여 값을 변경하면, 원본 배열인 `numArr`가 가리키는 메모리의 데이터가 직접 변경된다. 그렇기에 함수 종료 후 `numArr[0]`을 출력하면 `1`에서 변경된 값인 `99`가 출력된다.

---
<br>

> ## 문제 3. 출력결과 판단하기 2
* 함수에 인자가 전달될 때 일어나는 일과 연관하여 어떤 출력 결과가 나오는지 설명하시오
```csharp
void ReplaceList(int[] arr)
{
    arr = new int[] { 9, 9, 9 };
}

int[] numArr = new int[] { 1, 2, 3 };
ReplaceList(numArr);
Console.WriteLine(numArr[0]); 

// 출력 결과: ?
```

### 출력 결과 : `1`

설명: 함수에 인자가 전달될 때, 참조 타입 변수인 `numArr`의 **주소값이 복사(Pass by Value)** 되어 매개변수 `arr`에 들어간다.   
함수 내부에서 `arr = new int[] { 9, 9, 9 };`를 실행하면, 매개변수 `arr`는 **새로운 배열 객체**를 가리키게 된다.   
하지만 이것은 복사된 지역변수 `arr`가 가리키는 대상이 바뀐 것일 뿐, 원본 변수 `numArr`가 가리키고 있는 주소에는 아무런 영향을 주지 않는다.    
`new`로 **새로운 메모리 공간을 할당**하였기 때문이다. 따라서 원본 배열의 첫 번째 값인 `1`이 그대로 출력된다.

---
<br>

> ## 문제 4(심화/선택사항)
* 예시 코드 1번과 2번의 출력 결과를 적고, 동작 차이가 어떻게 다른지 설명하시오.

예시 코드 1 — ref 붙어있지 않은 코드
```csharp
void Modify(int[] arr)
{
    arr[1] = 500;
}

int[] numArr = new int[] { 10, 20, 30 };
Modify(numArr);
Console.WriteLine(numArr[1]);

// 출력 결과: ?
```

예시 코드 2 — ref가 붙어있는 코드
```csharp
void ModifyRef(ref int[] arr)
{
    arr = new int[] { 7, 7, 7 };
}

int[] numArr2 = new int[] { 10, 20, 30 };
ModifyRef(ref numArr2);
Console.WriteLine(numArr2[0]); 

// 출력 결과: ?
```