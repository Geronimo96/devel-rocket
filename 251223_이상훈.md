> ## 과제 1. 트레이너와 몬스터 클래스 제작
* 트레이너와 몬스터 클래스를 구현하시오.
* 각 클래스는 다음과 같은 속성과 기능을 지녀야 한다.

    Class Trainer
    * 이름 : 플레이어 이름, 프로그램 시작 시 입력하도록 구현
    * 몬스터를 보관할 수 있는 크기 6의 배열
    * 현재 플레이어가 꺼내놓은 몬스터에 대한 참조를 위한 변수
    * Add() : 매개변수로 몬스터를 하나 입력받아 배열의 빈 자리에 추가. 빈 자리가 없다면 추가되지 않음
    * Remove() : 매개변수로 몬스터를 하나 입력받아(혹은 몬스터 이름이 적힌 문자열) 동일한 이름을 가진 몬스터를 배열에서 삭제. 이름에 해당하는 몬스터가 없거나 배열에 몬스터가 한마리도 없는 경우 아무 기능도 수행하지 않음.
    * PrintAll() : 자신이 가지고 있는 모든 포켓몬에 대한 정보를 출력
    * Attack() : 몬스터에게 공격 명령을 내림
    * Skill() : 몬스터에게 스킬 사용 명령을 내림

    Class Monster
    * 이름, 레벨 : 객체의 인스턴스 생성 시 new할당에서 이름과 레벨을 입력받을 수 있도록 구현
    * Print() : 자신(몬스터)에 대한 정보를 출력
    * Attack() : $"{몬스터의 이름} : {레벨 * 공격력} 데미지로 공격"을 출력
    * Skill() : Monster를 상속받은 하위 객체에서 세부구현
    * 세부 구현되는 몬스터가 Monster 클래스를 상속받도록 한다

    Class 세부구현 몬스터
    * Monster를 상속받아 Skill을 세부구현 한다.
        * 몬스터마다 고유한 스킬 이름을 출력한다
    * 세부구현 몬스터는 5종 이상을 구현한다.
  
  ```csharp

  ```
  
  ---
  <br>

>## 과제 2. 출력결과 판단하기 1
* 함수에 인자가 전달될 때 일어나는 일과 연관하여 어떤 출력 결과가 나오는지 설명하시오

```csharp
void UpdateList(int[] arr)
{
    arr[0] = 99;
}

int[] numArr = new int[] { 1, 2, 3 };
UpdateList(numArr);
Console.WriteLine(numArr[0]); 

// 출력 결과: ?
```
### 출력 결과 : `99`

설명: 배열은 **참조 타입(Reference Type)** 입니다. UpdateList(`numArr`)를 호출할 때, 배열의 값이 복사되는 것이 아니라 **배열이 위치한 메모리의 주소값(참조)** 이 전달됩니다. 즉 `깊은 복사`가 아닌 `얕은 복사`가 일어난다. 따라서 함수 내부에서 `arr[0]`에 접근하여 값을 변경하면, 원본 배열인 `numArr`가 가리키는 메모리의 데이터가 직접 변경됩니다. 그렇기에 함수 종료 후 `numArr[0]`을 출력하면 `1`에서 변경된 값인 `99`가 출력됩니다.

---
<br>

> ## 문제 3. 출력결과 판단하기 2
* 함수에 인자가 전달될 때 일어나는 일과 연관하여 어떤 출력 결과가 나오는지 설명하시오
```csharp
void ReplaceList(int[] arr)
{
    arr = new int[] { 9, 9, 9 };
}

int[] numArr = new int[] { 1, 2, 3 };
ReplaceList(numArr);
Console.WriteLine(numArr[0]); 

// 출력 결과: ?
```

### 출력 결과 : `1`

설명: 함수에 인자가 전달될 때, 참조 타입 변수인 `numArr`의 **주소값이 복사(Pass by Value)** 되어 매개변수 `arr`에 들어간다.   
함수 내부에서 `arr = new int[] { 9, 9, 9 };`를 실행하면, 매개변수 `arr`는 **새로운 배열 객체**를 가리키게 된다.   
하지만 이것은 복사된 지역변수 `arr`가 가리키는 대상이 바뀐 것일 뿐, 원본 변수 `numArr`가 가리키고 있는 주소에는 아무런 영향을 주지 않는다.    
`new`로 **새로운 메모리 공간을 할당**하였기 때문이다. 따라서 원본 배열의 첫 번째 값인 `1`이 그대로 출력된다.

---
<br>

> ## 문제 4(심화/선택사항)
* 예시 코드 1번과 2번의 출력 결과를 적고, 동작 차이가 어떻게 다른지 설명하시오.

예시 코드 1 — ref 붙어있지 않은 코드
```csharp
void Modify(int[] arr)
{
    arr[1] = 500;
}

int[] numArr = new int[] { 10, 20, 30 };
Modify(numArr);
Console.WriteLine(numArr[1]);

// 출력 결과: ?
```

예시 코드 2 — ref가 붙어있는 코드
```csharp
void ModifyRef(ref int[] arr)
{
    arr = new int[] { 7, 7, 7 };
}

int[] numArr2 = new int[] { 10, 20, 30 };
ModifyRef(ref numArr2);
Console.WriteLine(numArr2[0]); 

// 출력 결과: ?
```