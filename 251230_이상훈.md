
>## 과제 1. 자판기

* 음료를 순서대로 꺼내는 자판기 클래스를 구현하시오
    * Milk 및 VendingMachine 클래스 생성
    * Milk의 필드 변수로 유통기한을 나타내는 int타입 변수를 가진다
    * VendingMachine 클래스에는 Queue를 활용하여 Milk를 담을 수 있는 컨테이너를 필드로 가진다
    * 벤딩머신의 메소드로, 우유를 집어넣는 코드와 우유를 꺼내는 기능을 작성하되, 꺼낼때는 콘솔에 유통기한 및 큐에 남아있는 갯수를 출력하는 기능을 작성. 갯수가 0일때 우유를 꺼내는 기능을 호출하게 되면 꺼내는 대신 다른 멘트가 나오게끔 작성한다

```cs
using System;
using System.Collections.Generic; // Queue를 사용하기 위해 필요한 네임스페이스

namespace VendingMachineApp
{
    // 1. Milk 클래스: 우유의 정보를 담는 클래스
    public class Milk
    {
        // 유통기한을 나타내는 int 타입 필드 변수
        public int expirationDate;

        // 생성자: 우유 생성 시 유통기한을 설정
        public Milk(int date)
        {
            this.expirationDate = date;
        }
    }

    // 2. VendingMachine 클래스: 자판기 기능을 수행하는 클래스
    public class VendingMachine
    {
        // Milk를 담을 수 있는 컨테이너 (Queue 활용)
        // private으로 선언하여 외부에서 직접 접근하지 못하게 캡슐화
        private Queue<Milk> milkStorage;

        public VendingMachine()
        {
            // 자판기 생성 시 큐 초기화
            milkStorage = new Queue<Milk>();
        }

        // 기능 1: 우유를 집어넣는 메서드 (Enqueue)
        public void PutMilk(Milk milk)
        {
            milkStorage.Enqueue(milk);
            Console.WriteLine($"[입고] 우유가 채워졌습니다. (유통기한: {milk.expirationDate}일)");
        }

        // 기능 2: 우유를 꺼내는 메서드 (Dequeue)
        public void GetMilk()
        {
            // 갯수가 0일 때 예외 처리
            if (milkStorage.Count == 0)
            {
                Console.WriteLine(">>> [알림] 현재 자판기에 남은 우유가 없습니다. 다시 채워주세요.");
                return; // 메서드 종료
            }

            // 큐에서 우유를 하나 꺼냄 (가장 먼저 들어간 우유)
            Milk milk = milkStorage.Dequeue();

            // 요구사항: 꺼낼 때 유통기한 및 남은 갯수 출력
            Console.WriteLine("----------------------------------");
            Console.WriteLine($"[출고] 우유가 나왔습니다!");
            Console.WriteLine($" - 유통기한: {milk.expirationDate}일");
            Console.WriteLine($" - 자판기 남은 수량: {milkStorage.Count}개");
            Console.WriteLine("----------------------------------");
        }
    }

    // 실행을 위한 Main 클래스
    class Program
    {
        static void Main(string[] args)
        {
            // 자판기 인스턴스 생성
            VendingMachine vm = new VendingMachine();

            // 우유 객체 생성 (유통기한을 다르게 설정)
            Milk m1 = new Milk(10); // 유통기한 10일
            Milk m2 = new Milk(7);  // 유통기한 7일
            Milk m3 = new Milk(5);  // 유통기한 5일

            // 1. 우유 입고 (PutMilk)
            Console.WriteLine("=== 우유 채우기 시작 ===");
            vm.PutMilk(m1);
            vm.PutMilk(m2);
            vm.PutMilk(m3);
            Console.WriteLine();

            // 2. 우유 꺼내기 (GetMilk) - 순서대로 나옴
            Console.WriteLine("=== 우유 꺼내기 시작 ===");
            vm.GetMilk(); // m1(10일) 나옴
            vm.GetMilk(); // m2(15일) 나옴
            vm.GetMilk(); // m3(20일) 나옴

            // 3. 빈 자판기에서 꺼내기 테스트
            Console.WriteLine();
            vm.GetMilk(); // 재고 없음 멘트 출력
        }
    }
}
```

>## 과제 2. 카드 덱

* 카드 덱을 구현하시오.
    * Shape라는 Enum을 만들어서 Spade, Heart, Clover, Diamond 네 가지를 요소로 가지게 한다
    * Card라는 클래스를 선언하고, 위 열거형을 Card클래스 맴버변수로 가지게 한다.
    * Card클래스에는 숫자를 나타내는 int형을 넣되, a는 1, J는 11, Q는 12, K는 13이라고 가정한다.
    * CardDeck이라는 클래스를 선언, Card 객체를 52개 담을 수 있는 ???(자료구조) 들을 활용하여 두 개 만들되, 하나는 unusedCards, 하나는 usedCards 의 이름으로 선언한다.
    * 해당 자료구조를 왜 선택했는지에 대한 내용도 서술
    * CardDeck 클래스의 생성자에 unusedCards 속 52개의 Card를 중복없이 뉴할당해서 넣어주는 코드를 작성하한다. 카드를 섞는 메소드를 작성하거나 생성자에서 바로 진행할 수 있다
    * CardDeck 클래스에 아직 쓰지 않은 맨 위 카드를 보기만 하는 ShowTopCard 기능을 제작한다. 이는 맨 상단의 카드를 보기만 할 뿐 카드를 소모하진 않습니다.
    * DrawCard라는 메소드를 제작한다.
    * 이 메소드는 아직 쓰지 않은 덱의 맨 위 카드를 반환받고 그와 동시에 usedCard에 쌓는 기능을 수행합니다.

### 💡 자료구조 선택 이유: `Stack<T>` (스택)

**"맨 위 카드를 본다(Peek)"** 와 **"맨 위 카드를 뽑는다(Pop)"** 라는 동작에 가장 부합하는 자료구조는 **`Stack<T>`(스택)** 이다.

**Stack(스택)**을 선택한 이유는 카드 덱의 물리적 특성을 가장 잘 반영하기 때문이다.


```cs
using System;
using System.Collections.Generic; // Stack, List 사용을 위한 네임스페이스

namespace CardGameApp
{
    // 1. Shape Enum: 카드 문양 정의
    public enum Shape
    {
        Spade,
        Heart,
        Clover,
        Diamond
    }

    // 2. Card 클래스: 개별 카드 정보
    public class Card
    {
        public Shape CardShape { get; private set; } // 문양
        public int Number { get; private set; }      // 숫자 (1~13)

        public Card(Shape shape, int number)
        {
            this.CardShape = shape;
            this.Number = number;
        }

        // 카드의 정보를 보기 좋게 출력하기 위해 재정의
        public override string ToString()
        {
            string numberString;
            switch (Number)
            {
                case 1: numberString = "A"; break;
                case 11: numberString = "J"; break;
                case 12: numberString = "Q"; break;
                case 13: numberString = "K"; break;
                default: numberString = Number.ToString(); break;
            }
            return $"[{CardShape} {numberString}]";
        }
    }

    // 3. CardDeck 클래스: 덱 관리
    public class CardDeck
    {
        // ??? (자료구조) -> Stack<Card> 선택
        private Stack<Card> unusedCards; // 사용 전 카드 덱 (뽑을 덱)
        private Stack<Card> usedCards;   // 사용 후 카드 덱 (버린 덱)

        // 생성자: 52장의 카드를 생성하고 섞어서 unusedCards에 넣음
        public CardDeck()
        {
            unusedCards = new Stack<Card>();
            usedCards = new Stack<Card>();

            // 임시 리스트 생성 (스택은 섞는 기능이 없으므로 리스트에서 섞고 스택에 담음)
            List<Card> tempDeck = new List<Card>();

            // 4가지 문양 * 13개 숫자 = 52개 생성
            foreach (Shape shape in Enum.GetValues(typeof(Shape)))
            {
                for (int i = 1; i <= 13; i++)
                {
                    tempDeck.Add(new Card(shape, i));
                }
            }

            // 카드 섞기 (Shuffle)
            Shuffle(tempDeck);

            // 섞인 카드를 스택(unusedCards)에 차곡차곡 쌓음
            foreach (Card card in tempDeck)
            {
                unusedCards.Push(card);
            }
        }

        // 내부적으로 사용하는 셔플 메서드 (Fisher-Yates 알고리즘 변형)
        private void Shuffle(List<Card> list)
        {
            Random rand = new Random();
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = rand.Next(n + 1);
                // Swap
                Card value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        // 기능 1: 맨 위 카드 보기 (ShowTopCard) - 소모하지 않음
        public void ShowTopCard()
        {
            if (unusedCards.Count > 0)
            {
                // Peek(): 꺼내지 않고 맨 위의 값만 확인
                Card topCard = unusedCards.Peek();
                Console.WriteLine($"--- 맨 위 카드 확인(Peek): {topCard} ---");
            }
            else
            {
                Console.WriteLine("확인할 카드가 없습니다.");
            }
        }

        // 기능 2: 카드 뽑기 (DrawCard) - 반환 및 usedCard로 이동
        public Card DrawCard()
        {
            if (unusedCards.Count > 0)
            {
                // Pop(): 스택에서 꺼내면서 제거
                Card drawnCard = unusedCards.Pop();
                
                // 뽑은 카드를 usedCards(버린 덱)에 Push
                usedCards.Push(drawnCard);

                return drawnCard;
            }
            else
            {
                Console.WriteLine("더 이상 뽑을 카드가 없습니다.");
                return null;
            }
        }

        // 현재 덱 상태 출력용 메서드 (테스트용)
        public void PrintDeckStatus()
        {
            Console.WriteLine($"[현재 상태] 남은 카드: {unusedCards.Count}장 | 사용한 카드: {usedCards.Count}장");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // 덱 생성 (생성자에서 52장 생성 및 셔플 완료)
            CardDeck deck = new CardDeck();
            
            Console.WriteLine("=== 카드 덱 생성 완료 ===");
            deck.PrintDeckStatus();
            Console.WriteLine();

            // 1. 맨 위 카드 확인해보기 (소모 안 됨)
            deck.ShowTopCard();
            deck.PrintDeckStatus(); // 갯수 변화 없어야 함
            Console.WriteLine();

            // 2. 카드 한 장 뽑기
            Console.WriteLine(">>> 카드 한 장을 뽑습니다(Draw).");
            Card myCard1 = deck.DrawCard();
            Console.WriteLine($"내가 뽑은 카드: {myCard1}");
            deck.PrintDeckStatus(); // unused -1, used +1 되어야 함
            Console.WriteLine();

            // 3. 또 뽑기
            Console.WriteLine(">>> 카드 한 장을 더 뽑습니다(Draw).");
            Card myCard2 = deck.DrawCard();
            Console.WriteLine($"내가 뽑은 카드: {myCard2}");
            deck.PrintDeckStatus();
            
            // 4. 맨 위 카드 다시 확인 (이전과는 다른 카드여야 함)
            Console.WriteLine();
            deck.ShowTopCard();
        }
    }
}
```
  
>## 과제 3(심화/선택사항) Dequeue
* 자료구조 중에는 Deque라는 자료구조도 존재하지만, 현재 C#에서는 Stack과 Queue처럼 구현체가 없다.
    * Deque가 무엇인지 조사하고 C#을 사용해 다음의 조건을 충족하는 Mydeque 클래스를 구현하시오
    * 제네릭 컬렉션의 사용을 금지하며, 배열을 사용해 구현한다.
    * 클래스의 인스턴스 생성 시 최초 10의 크기를 가진다.
    * 배열의 크기를 넘어서 데이터를 추가할 경우, 배열에 빈 자리가 없다면 현재 배열의 크기의 2배만큼 재할당해야 한다.
    * 아래 필수 구현 메서드 외 내부 동작을 위한 필드 및 메서드 추가는 허용한다.
    
* 구현 메서드
    * PushFront(T element) : 배열의 맨 앞에 데이터를 추가한다.
    * PushBack(T element) : 배열의 맨 뒤에 데이터를 추가한다.
    * PopFront() : 배열의 가장 앞의 데이터를 반환하고, 내부 배열에서 삭제한다.
    * PopBack() : 배열의 가장 뒤의 데이터를 반환하고, 내부 배열에서 삭제한다.
    * Clear() : 배열 내의 모든 데이터를 삭제한다.

* 해당 과제를 수행할 경우 제출하는 마크다운 문서에 기재하여 제출합니다